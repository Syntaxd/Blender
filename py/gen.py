import numpy as np

def interpolant(t):
    return t * t * t * (t * (t * 6 - 15) + 10)


def generate_perlin_noise_2d(
        shape, res, tileable=(False, False), interpolant=interpolant
):
    """Generate a 2D numpy array of perlin noise.
    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multple of res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).
    Returns:
        A numpy array of shape shape with the generated noise.
    Raises:
        ValueError: If shape is not a multiple of res.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]] \
               .transpose(1, 2, 0) % 1
    # Gradients
    angles = 2 * np.pi * np.random.rand(res[0] + 1, res[1] + 1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    if tileable[0]:
        gradients[-1, :] = gradients[0, :]
    if tileable[1]:
        gradients[:, -1] = gradients[:, 0]
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[:-d[0], :-d[1]]
    g10 = gradients[d[0]:, :-d[1]]
    g01 = gradients[:-d[0], d[1]:]
    g11 = gradients[d[0]:, d[1]:]
    # Ramps
    n00 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1])) * g00, 2)
    n10 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1])) * g10, 2)
    n01 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1] - 1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1] - 1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00 * (1 - t[:, :, 0]) + t[:, :, 0] * n10
    n1 = n01 * (1 - t[:, :, 0]) + t[:, :, 0] * n11
    return np.sqrt(2) * ((1 - t[:, :, 1]) * n0 + t[:, :, 1] * n1)


def generate_fractal_noise_2d(
        shape, res, octaves=1, persistence=0.5,
        lacunarity=2, tileable=(False, False),
        interpolant=interpolant
):
    """Generate a 2D numpy array of fractal noise.
    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The, interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).
    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.
    Raises:
        ValueError: If shape is not a multiple of
            (lacunarity**(octaves-1)*res).
    """
    noise = np.zeros(shape)
    frequency = 1
    amplitude = 1
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(
            shape, (frequency * res[0], frequency * res[1]), tileable, interpolant
        )
        frequency *= lacunarity
        amplitude *= persistence
    return noise


def generate_old_landscape():
    p = generate_fractal_noise_2d((256, 256), (8, 8), 5)

    import time
    import bpy
    rx = 2
    ry = 2
    file_loc = '/Users/ryan/Projects/3db/Grass/Gen.obj'
    for x in range(rx):
        for y in range(ry):
            start_time = time.time()
            h = p[x][y]
            if y < 1 and x < 1:
                imported_object = bpy.ops.import_scene.obj(filepath=file_loc)
            else:
                bpy.ops.object.duplicate()
            block = bpy.context.selected_objects[0]
            block.location = (x*2,y*2,h*10)

            print('Imported ground block: ' + block.name + ' at ' +str(x)+', '+str(y)+', ' + str(round(h, 2)) + "\n", end='', flush=True)


#bpy.ops.mesh.primitive_grid_add(
#    x_subdivisions=10,
#    y_subdivisions=10,
#    size=2.0,
#    calc_uvs=True,
#    enter_editmode=False,
#    align='WORLD',
#    location=(0.0, 0.0, 0.0),
#    rotation=(0.0, 0.0, 0.0),
#    scale=(0.0, 0.0, 0.0)
#)
def create_grid(p, scale):
    import time
    import bpy

    print("-" * 33)
    print(p.shape)
    print(p)
    i, j = p.shape

    bpy.ops.mesh.primitive_grid_add(
        x_subdivisions=i,
        y_subdivisions=j,
        size=10,
        calc_uvs=True,
    )

    grid = bpy.context.object

    for v in grid.data.vertices:
        v.co.z = scale * p[v.index // i][v.index % j]


def add_gaussian(p, x_center=100, y_center=100, height=10, sigma=5000):
    import math
    shape = p.shape
    print(shape)
    for x in range(0, shape[0]):
        for y in range(0, shape[1]):
#            print(x, y, math.exp(-(x-x_center)*(x-x_center) + (y-y_center)*(y-y_center)/sigma))
#            print(x, y, math.exp(-(x-x_center)*(x-x_center) + (y-y_center)*(y-y_center)/sigma))
            p[x,y] = p[x,y] + height * math.exp(
                -((x-x_center)*(x-x_center) + (y-y_center)*(y-y_center))/sigma
            )

def generate_landscape():
    shape = (512, 512)
#    p = generate_fractal_noise_2d(shape, (8, 8), 5)

    res = (8, 8)
    scale = 0.25
    p = generate_perlin_noise_2d(
        shape, res, tileable=(True, True), interpolant=interpolant)

    add_gaussian(p, x_center=200, y_center=200, height=10, sigma=5000)
    add_gaussian(p, x_center=400, y_center=400, height=5, sigma=1000)
    create_grid(p, scale)


#generate_old_landscape()
generate_landscape()
