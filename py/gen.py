import random
import math

def points(size):
    num_points = 3
    threshold = .3


    def dist(p1, p2):
        return math.sqrt(math.pow(p1[0]-p2[0], 2) + math.pow(p1[1] - p2[1], 2))


    final_list = []
    while len(final_list) < num_points:
        count = 0
        while True:
            count += 1

            if count > 10000:
                raise Exception('Can\'t generate any more points')
            point = [random.random(), random.random()]

            if not len(final_list):
                # First point
                final_list.append(point)
            else:
                # Check if it is too close to any other points
                valid = True
                for p in final_list:

                    d1 = dist(p, point)
                    if d1 < threshold:
                        valid = False
                        break

                if valid:
                    final_list.append(point)
                    break


    print('================================')
    print('FIANL LIST')
    for x in final_list:
        x[0]*=size
        x[1]*=size
    print(x)
    return final_list

import numpy as np

def interpolant(t):
    return t * t * t * (t * (t * 6 - 15) + 10)


def generate_perlin_noise_2d(
        shape, res, tileable=(False, False), interpolant=interpolant
):
    """Generate a 2D numpy array of perlin noise.
    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multple of res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            res.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).
    Returns:
        A numpy array of shape shape with the generated noise.
    Raises:
        ValueError: If shape is not a multiple of res.
    """
    delta = (res[0] / shape[0], res[1] / shape[1])
    d = (shape[0] // res[0], shape[1] // res[1])
    grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]] \
               .transpose(1, 2, 0) % 1
    # Gradients
    angles = 2 * np.pi * np.random.rand(res[0] + 1, res[1] + 1)
    gradients = np.dstack((np.cos(angles), np.sin(angles)))
    if tileable[0]:
        gradients[-1, :] = gradients[0, :]
    if tileable[1]:
        gradients[:, -1] = gradients[:, 0]
    gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
    g00 = gradients[:-d[0], :-d[1]]
    g10 = gradients[d[0]:, :-d[1]]
    g01 = gradients[:-d[0], d[1]:]
    g11 = gradients[d[0]:, d[1]:]
    # Ramps
    n00 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1])) * g00, 2)
    n10 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1])) * g10, 2)
    n01 = np.sum(np.dstack((grid[:, :, 0], grid[:, :, 1] - 1)) * g01, 2)
    n11 = np.sum(np.dstack((grid[:, :, 0] - 1, grid[:, :, 1] - 1)) * g11, 2)
    # Interpolation
    t = interpolant(grid)
    n0 = n00 * (1 - t[:, :, 0]) + t[:, :, 0] * n10
    n1 = n01 * (1 - t[:, :, 0]) + t[:, :, 0] * n11
    return np.sqrt(2) * ((1 - t[:, :, 1]) * n0 + t[:, :, 1] * n1)


def generate_fractal_noise_2d(
        shape, res, octaves=1, persistence=0.5,
        lacunarity=2, tileable=(False, False),
        interpolant=interpolant
):
    """Generate a 2D numpy array of fractal noise.
    Args:
        shape: The shape of the generated array (tuple of two ints).
            This must be a multiple of lacunarity**(octaves-1)*res.
        res: The number of periods of noise to generate along each
            axis (tuple of two ints). Note shape must be a multiple of
            (lacunarity**(octaves-1)*res).
        octaves: The number of octaves in the noise. Defaults to 1.
        persistence: The scaling factor between two octaves.
        lacunarity: The frequency factor between two octaves.
        tileable: If the noise should be tileable along each axis
            (tuple of two bools). Defaults to (False, False).
        interpolant: The, interpolation function, defaults to
            t*t*t*(t*(t*6 - 15) + 10).
    Returns:
        A numpy array of fractal noise and of shape shape generated by
        combining several octaves of perlin noise.
    Raises:
        ValueError: If shape is not a multiple of
            (lacunarity**(octaves-1)*res).
    """
    noise = np.zeros(shape)
    frequency = 1
    amplitude = 1
    for _ in range(octaves):
        noise += amplitude * generate_perlin_noise_2d(
            shape, (frequency * res[0], frequency * res[1]), tileable, interpolant
        )
        frequency *= lacunarity
        amplitude *= persistence
    return noise

def generate_gaussian(shape, x_center=100, y_center=100, height=10, sigma=5000):
    import math
    p = np.zeros(shape)
    for x in range(0, shape[0]):
        for y in range(0, shape[1]):
            p[x,y] = p[x,y] + height * math.exp(
                -((x-x_center)*(x-x_center) + (y-y_center)*(y-y_center))/sigma
            )
    return p


def add_gaussian(p, x_center=100, y_center=100, height=10, sigma=5000):
    import math
    shape = p.shape

    for x in range(0, shape[0]):
        for y in range(0, shape[1]):
            p[x,y] = p[x,y] + height * math.exp(
                -((x-x_center)*(x-x_center) + (y-y_center)*(y-y_center))/sigma
            )


def create_grid(p, scale):
    import time
    import bpy

    print("-" * 33)
    i, j = p.shape

    bpy.ops.mesh.primitive_grid_add(
        x_subdivisions=i,
        y_subdivisions=j,
        size=10,
        calc_uvs=True,
    )

    grid = bpy.context.object
    for v in grid.data.vertices:
        v.co.z = scale * p[v.index // i][v.index % j]


def generate_landscape():
    shape = (512, 512)
#    p = generate_fractal_noise_2d(shape, (8, 8), 5)

    scale = 0.25

    res_2 = (64, 64)
    p_2 = generate_perlin_noise_2d(
        shape, res_2, tileable=(True, True), interpolant=interpolant)
    p_2 = p_2 * 0.25

    res_1 = (32, 32)
    p_1 = generate_perlin_noise_2d(
        shape, res_1, tileable=(True, True), interpolant=interpolant)
    p_1 = p_1 * 0.5

    res0 = (16, 16)
    p0 = generate_perlin_noise_2d(
        shape, res0, tileable=(True, True), interpolant=interpolant)
    p0 = p0 * 1

    res1 = (8, 8)
    p1 = generate_perlin_noise_2d(
        shape, res1, tileable=(True, True), interpolant=interpolant)
    p1 = p1 * 2

    res2 = (4, 4)
    p2 = generate_perlin_noise_2d(
        shape, res2, tileable=(True, True), interpolant=interpolant)
    p2 = p2 * 4

    res3 = (2, 2)
    p3 = generate_perlin_noise_2d(
        shape, res3, tileable=(True, True), interpolant=interpolant)
    p3 = p3 * 8


    g = np.zeros(shape)
    gau_list = points(512)
    print(gau_list)
    for gau in gau_list:
        print(gau)
        g+=generate_gaussian(shape, x_center=gau[0], y_center=gau[1], height=20, sigma=15000)

    p = p3 + p2 + p1 + p0 + p_1 + p_2 + g

    # add_gaussian(p, x_center=200, y_center=200, height=10, sigma=5000)
    # add_gaussian(p, x_center=400, y_center=400, height=5, sigma=1000)
    create_grid(p, scale)


#generate_old_landscape()
generate_landscape()
